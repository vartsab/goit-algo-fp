# goit-algo-fp

# Basic Algorythms and Data Structures. Final Project


## 1. Linked List
Dive into the world of linked lists with this Python project! It showcases a variety of operations:
- Reverse a List: Flip the order of elements in a singly linked list.
- Merge Sort: Sort the list using the classic merge sort algorithm.
- Merge Two Sorted Lists: Combine two sorted linked lists into a single, sorted list.

To check out these features, just run main.py. It kicks off with two linked lists filled with random prime numbers, shows off the different operations, and displays the results.

## 2. Pythagoras Tree Fractal
This Python program brings the Pythagoras Tree fractal to life using recursion. You can set the depth of recursion, creating fractals of varying complexity.

### Features
- Recursive Tree Generation: Watch the Pythagoras Tree grow.
- Customizable Complexity: Adjust the recursion depth to change the visual detail.
#### Usage
Simply enter the desired recursion level when prompted. The program uses the turtle library for a delightful visualization.

### 3. Dijkstra's Algorithm
Explore shortest path calculations with Dijkstra's algorithm! This project not only finds the shortest paths but also visualizes the graph. You can add edges, compute paths, and see the graph in action.

#### Requirements
- networkx
- matplotlib

### 4. Heap Visualization
Visualize a binary heap like never before! This project represents heaps using an array and visualizes them as binary trees. Whether it's a max or min heap, the draw_heap_tree function has got you covered.

#### How to Use
Create a heap array.
Visualize it with draw_heap_tree(heap_array).
#### Requirements
- Python 3.x
- networkx
- matplotlib

### 5. Binary Tree Traversal Visualization
Experience binary tree traversals with this Python project! It visualizes BFS and DFS algorithms using networkx and matplotlib. Nodes are color-coded based on the traversal order, shifting from dark to light shades. A great way to understand tree traversal techniques!

### 6. Greedy Algorithm and Dynamic Programming
This project tackles the problem of selecting the best food items to maximize calorie intake within a budget. It uses two strategies: a greedy algorithm and dynamic programming. The greedy method focuses on the calorie-to-cost ratio, while dynamic programming finds the perfect combo.

### 7. Monte Carlo Simulation for Dice Rolls
Ever wondered about the probabilities of dice sums? This project simulates rolling two dice using the Monte Carlo method, calculating the probabilities of each possible sum (2-12). It compares these simulated results with theoretical probabilities, showing how well the Monte Carlo method estimates them.

The simulation shows that the theoretical calculations match up well with the actual data, proving that the Monte Carlo method is a reliable way to estimate probabilities.

|Sum|Monte Carlo Probability|Analytical Probability| Difference|
|-|-:|-:|-:|
|2|2.7717%|2.7778%|0.0061%|
|3|5.5282%|5.5556%|0.0274%|
|4|8.3608%|8.3333%|0.0275%|
|5|11.1222%|11.1111%|0.0111%|
|6|13.8661%|13.8889%|0.0228%|
|7|16.6600%|16.6667%|0.0067%|
|8|13.9309%|13.8889%|0.0420%|
|9|11.0967%|11.1111%|0.0144%|
|10|8.3306%|8.3333%|0.0027%|
|11|5.5865%|5.5556%|0.0309%|
|12|2.7463%|2.7778%|0.0315%|



#### Usage
Run the simulation with a set number of trials.
Compare the simulated probabilities with theoretical values.
Check out the results in a table and graph format.